/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.4.2.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import type {
  CosmWasmClient,
  ExecuteResult,
  SigningCosmWasmClient,
} from "@cosmjs/cosmwasm-stargate";
import type { StdFee } from "@cosmjs/amino";

export interface AddressAllDomainResponse {
  domains: string[];
  [k: string]: unknown;
}
export interface CanRegisterResponse {
  can_register: boolean;
  [k: string]: unknown;
}
export type ExecuteMsg =
  | {
      admin: AdminExecuteMsg;
    }
  | {
      register: {
        domain: string;
        [k: string]: unknown;
      };
    }
  | {
      update_record: {
        data: DomainData;
        domain: string;
        [k: string]: unknown;
      };
    }
  | {
      set_primary: {
        domain: string;
        [k: string]: unknown;
      };
    }
  | {
      on_nft_owner_changed: {
        domain: string;
        new_owner: string;
        previous_owner: string;
        [k: string]: unknown;
      };
    }
  | {
      on_nft_burned: {
        caller: string;
        domain: string;
        previous_owner: string;
        [k: string]: unknown;
      };
    };
export type AdminExecuteMsg =
  | {
      withdraw_funds: {
        amount: Coin;
        beneficiary: string;
        [k: string]: unknown;
      };
    }
  | {
      add_extension: {
        extension: string;
        [k: string]: unknown;
      };
    }
  | {
      update_price_scheme: {
        new_price_scheme: PriceScheme;
        [k: string]: unknown;
      };
    };
export type Uint128 = string;
export type Addr = string;
export interface Coin {
  amount: Uint128;
  denom: string;
  [k: string]: unknown;
}
export interface PriceScheme {
  price_ranges: PriceRange[];
  [k: string]: unknown;
}
export interface PriceRange {
  max: number;
  min: number;
  price: Coin;
  [k: string]: unknown;
}
export interface DomainData {
  address?: Addr | null;
  avatar?: NftAvatarData | null;
  description?: string | null;
  email?: string | null;
  github?: string | null;
  twitter?: string | null;
  website?: string | null;
  background?: string | null;
  [k: string]: unknown;
}
export interface NftAvatarData {
  contract: string;
  token_id: string;
  [k: string]: unknown;
}
export interface ExtensionRegistrarAddressResponse {
  address: string;
  [k: string]: unknown;
}
export interface GetAllDomainsOwnedByResponse {
  domains: string[];
  owner: Addr;
  [k: string]: unknown;
}
export interface GetAllExtensionsResponse {
  extensions: string[];
  [k: string]: unknown;
}
export interface GetDomainDataResponse {
  domain_data: DomainData;
  [k: string]: unknown;
}
export type DomainStatus =
  | ("Available" | "Expired")
  | {
      Owned: {
        is_renewable: boolean;
        owner: Addr;
        registration_time: Timestamp;
        [k: string]: unknown;
      };
    };
export type Timestamp = Uint64;
export type Uint64 = string;
export interface GetDomainStatusResponse {
  domain_status: DomainStatus;
  [k: string]: unknown;
}
export type ValidationResult =
  | {
      Error: ValidationError;
    }
  | {
      Success: ValidationSuccess;
    };
export type ValidationError =
  | "DomainTooShort"
  | "DomainTooLong"
  | "NoSubdomainsAllowed"
  | "NormalizationFailed"
  | "ExtensionDoesNotExist"
  | "InvalidInput";
export interface GetNormalizedDomainAndPriceResponse {
  is_valid_domain: boolean;
  result: ValidationResult;
  [k: string]: unknown;
}
export interface ValidationSuccess {
  can_register: boolean;
  normalized_domain: string;
  pricing: Coin;
  [k: string]: unknown;
}
export interface GetNormalizedDomainResponse {
  normalization_successful: boolean;
  normalized_domain: string;
  [k: string]: unknown;
}
export interface GetNormalizerContractResponse {
  address: Addr;
  [k: string]: unknown;
}

export interface GetPrimaryResponse {
  domain?: string | null;

  [k: string]: unknown;
}

export interface GetPriceSchemeResponse {
  price_scheme: PriceScheme;
  [k: string]: unknown;
}
export interface GetStorageContractResponse {
  address: Addr;
  [k: string]: unknown;
}
export interface InstantiateMsg {
  admin: string;
  nft_code_id: number;
  price_scheme: PriceScheme;
  storage_code_id: number;
  uts46_normalizer: string;
  [k: string]: unknown;
}
export type QueryMsg =
  | {
      resolve_name: {
        domain: string;
        [k: string]: unknown;
      };
    }
  | {
      reverse_look_up: {
        target: string;
        [k: string]: unknown;
      };
    }
  | {
      get_domain_status: {
        domain: string;
        [k: string]: unknown;
      };
    }
  | {
      extension_registrar_address: {
        extension: string;
        [k: string]: unknown;
      };
    }
  | {
      get_domain_data: {
        domain: string;
        [k: string]: unknown;
      };
    }
  | {
      get_price_scheme: {
        [k: string]: unknown;
      };
    }
  | {
      get_normalized_domain: {
        domain: string;
        [k: string]: unknown;
      };
    }
  | {
      get_normalized_domain_and_price: {
        domain: string;
        [k: string]: unknown;
      };
    }
  | {
      get_all_domains_owned_by: {
        owner: string;
        [k: string]: unknown;
      };
    }
  | {
      get_all_extensions: {
        [k: string]: unknown;
      };
    }
  | {
      get_storage_contract: {
        [k: string]: unknown;
      };
    }
  | {
      get_normalizer_contract: {
        [k: string]: unknown;
      };
    }
  | {
      get_primary: {
        user_address: string;
        [k: string]: unknown;
      };
    };
export interface ResolveNameResponse {
  address?: Addr | null;
  [k: string]: unknown;
}
export interface ReverseLookUpResponse {
  address: Addr;
  domains: string[];
  [k: string]: unknown;
}
export interface ReverseRecordResponse {
  owner?: string | null;
  [k: string]: unknown;
}
export interface FetchNameSystemReadOnlyInterface {
  contractAddress: string;
  resolveName: ({ domain }: { domain: string }) => Promise<ResolveNameResponse>;
  reverseLookUp: ({
    target,
  }: {
    target: string;
  }) => Promise<ReverseLookUpResponse>;
  getDomainStatus: ({
    domain,
  }: {
    domain: string;
  }) => Promise<GetDomainStatusResponse>;
  extensionRegistrarAddress: ({
    extension,
  }: {
    extension: string;
  }) => Promise<ExtensionRegistrarAddressResponse>;
  getDomainData: ({
    domain,
  }: {
    domain: string;
  }) => Promise<GetDomainDataResponse>;
  getPriceScheme: () => Promise<GetPriceSchemeResponse>;
  getNormalizedDomain: ({
    domain,
  }: {
    domain: string;
  }) => Promise<GetNormalizedDomainResponse>;
  getNormalizedDomainAndPrice: ({
    domain,
  }: {
    domain: string;
  }) => Promise<GetNormalizedDomainAndPriceResponse>;
  getAllDomainsOwnedBy: ({
    owner,
  }: {
    owner: string;
  }) => Promise<GetAllDomainsOwnedByResponse>;
  getAllExtensions: () => Promise<GetAllExtensionsResponse>;
  getStorageContract: () => Promise<GetStorageContractResponse>;
  getNormalizerContract: () => Promise<GetNormalizerContractResponse>;
  getPrimary: ({
    userAddress,
  }: {
    userAddress: string;
  }) => Promise<GetPrimaryResponse>;
}
export class FetchNameSystemQueryClient
  implements FetchNameSystemReadOnlyInterface
{
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.resolveName = this.resolveName.bind(this);
    this.reverseLookUp = this.reverseLookUp.bind(this);
    this.getDomainStatus = this.getDomainStatus.bind(this);
    this.extensionRegistrarAddress = this.extensionRegistrarAddress.bind(this);
    this.getDomainData = this.getDomainData.bind(this);
    this.getPriceScheme = this.getPriceScheme.bind(this);
    this.getNormalizedDomain = this.getNormalizedDomain.bind(this);
    this.getNormalizedDomainAndPrice =
      this.getNormalizedDomainAndPrice.bind(this);
    this.getAllDomainsOwnedBy = this.getAllDomainsOwnedBy.bind(this);
    this.getAllExtensions = this.getAllExtensions.bind(this);
    this.getStorageContract = this.getStorageContract.bind(this);
    this.getNormalizerContract = this.getNormalizerContract.bind(this);
    this.getPrimary = this.getPrimary.bind(this);
  }

  resolveName = async ({
    domain,
  }: {
    domain: string;
  }): Promise<ResolveNameResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      resolve_name: {
        domain,
      },
    });
  };
  reverseLookUp = async ({
    target,
  }: {
    target: string;
  }): Promise<ReverseLookUpResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      reverse_look_up: {
        target,
      },
    });
  };
  getDomainStatus = async ({
    domain,
  }: {
    domain: string;
  }): Promise<GetDomainStatusResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_domain_status: {
        domain,
      },
    });
  };
  extensionRegistrarAddress = async ({
    extension,
  }: {
    extension: string;
  }): Promise<ExtensionRegistrarAddressResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      extension_registrar_address: {
        extension,
      },
    });
  };
  getDomainData = async ({
    domain,
  }: {
    domain: string;
  }): Promise<GetDomainDataResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_domain_data: {
        domain,
      },
    });
  };
  getPriceScheme = async (): Promise<GetPriceSchemeResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_price_scheme: {},
    });
  };
  getNormalizedDomain = async ({
    domain,
  }: {
    domain: string;
  }): Promise<GetNormalizedDomainResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_normalized_domain: {
        domain,
      },
    });
  };
  getNormalizedDomainAndPrice = async ({
    domain,
  }: {
    domain: string;
  }): Promise<GetNormalizedDomainAndPriceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_normalized_domain_and_price: {
        domain,
      },
    });
  };
  getAllDomainsOwnedBy = async ({
    owner,
  }: {
    owner: string;
  }): Promise<GetAllDomainsOwnedByResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_all_domains_owned_by: {
        owner,
      },
    });
  };
  getAllExtensions = async (): Promise<GetAllExtensionsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_all_extensions: {},
    });
  };
  getStorageContract = async (): Promise<GetStorageContractResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_storage_contract: {},
    });
  };
  getNormalizerContract = async (): Promise<GetNormalizerContractResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_normalizer_contract: {},
    });
  };
  getPrimary = async ({
    userAddress,
  }: {
    userAddress: string;
  }): Promise<GetPrimaryResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_primary: {
        user_address: userAddress,
      },
    });
  };
}
export interface FetchNameSystemInterface
  extends FetchNameSystemReadOnlyInterface {
  contractAddress: string;
  sender: string;
  admin: (
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: readonly Coin[]
  ) => Promise<ExecuteResult>;
  register: (
    {
      domain,
    }: {
      domain: string;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: readonly Coin[]
  ) => Promise<ExecuteResult>;
  updateRecord: (
    {
      data,
      domain,
    }: {
      data: DomainData;
      domain: string;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: readonly Coin[]
  ) => Promise<ExecuteResult>;
  setPrimary: (
    {
      domain,
    }: {
      domain: string;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: readonly Coin[]
  ) => Promise<ExecuteResult>;
  onNftOwnerChanged: (
    {
      domain,
      newOwner,
      previousOwner,
    }: {
      domain: string;
      newOwner: string;
      previousOwner: string;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: readonly Coin[]
  ) => Promise<ExecuteResult>;
  onNftBurned: (
    {
      caller,
      domain,
      previousOwner,
    }: {
      caller: string;
      domain: string;
      previousOwner: string;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: readonly Coin[]
  ) => Promise<ExecuteResult>;
}

export class FetchNameSystemClient
  extends FetchNameSystemQueryClient
  implements FetchNameSystemInterface
{
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(
    client: SigningCosmWasmClient,
    sender: string,
    contractAddress: string
  ) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.admin = this.admin.bind(this);
    this.register = this.register.bind(this);
    this.updateRecord = this.updateRecord.bind(this);
    this.setPrimary = this.setPrimary.bind(this);
    this.onNftOwnerChanged = this.onNftOwnerChanged.bind(this);
    this.onNftBurned = this.onNftBurned.bind(this);
  }

  admin = async (
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: readonly Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        admin: {},
      },
      fee,
      memo,
      funds
    );
  };
  register = async (
    {
      domain,
    }: {
      domain: string;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: readonly Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        register: {
          domain,
        },
      },
      fee,
      memo,
      funds
    );
  };
  updateRecord = async (
    {
      data,
      domain,
    }: {
      data: DomainData;
      domain: string;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: readonly Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_record: {
          data,
          domain,
        },
      },
      fee,
      memo,
      funds
    );
  };
  setPrimary = async (
    {
      domain,
    }: {
      domain: string;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: readonly Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        set_primary: {
          domain,
        },
      },
      fee,
      memo,
      funds
    );
  };
  onNftOwnerChanged = async (
    {
      domain,
      newOwner,
      previousOwner,
    }: {
      domain: string;
      newOwner: string;
      previousOwner: string;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: readonly Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        on_nft_owner_changed: {
          domain,
          new_owner: newOwner,
          previous_owner: previousOwner,
        },
      },
      fee,
      memo,
      funds
    );
  };
  onNftBurned = async (
    {
      caller,
      domain,
      previousOwner,
    }: {
      caller: string;
      domain: string;
      previousOwner: string;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: readonly Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        on_nft_burned: {
          caller,
          domain,
          previous_owner: previousOwner,
        },
      },
      fee,
      memo,
      funds
    );
  };
}
